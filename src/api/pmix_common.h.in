/*
 * Copyright (c) 2013-2014 Intel, Inc. All rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer listed
 *   in this license in the documentation and/or other materials
 *   provided with the distribution.
 *
 * - Neither the name of the copyright holders nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * The copyright holders provide no reassurances that the source code
 * provided does not infringe any patent, copyright, or any other
 * intellectual property rights of third parties.  The copyright holders
 * disclaim any liability to any recipient for claims brought against
 * recipient by any third party for infringement of that parties
 * intellectual property rights.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * $COPYRIGHT$
 * 
 * Additional copyrights may follow
 * 
 * $HEADER$
 */

#ifndef PMIx_COMMON_H
#define PMIx_COMMON_H

#include <stdint.h>
#include <string.h>
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h> /* for struct timeval */
#endif
#include <event.h>

#ifndef PMIX_CONFIG_H

/* ensure we have the version info available for external users */
#undef PMIX_MAJOR_VERSION
#undef PMIX_MINOR_VERSION
#undef PMIX_RELEASE_VERSION

#endif

#undef BEGIN_C_DECLS
#undef END_C_DECLS
#if defined(c_plusplus) || defined(__cplusplus)
# define BEGIN_C_DECLS extern "C" {
# define END_C_DECLS }
#else
#define BEGIN_C_DECLS          /* empty */
#define END_C_DECLS            /* empty */
#endif

BEGIN_C_DECLS

/****  PMIX CONSTANTS    ****/

/* define maximum value and key sizes */
#define PMIX_MAX_NSLEN     256
#define PMIX_MAX_VALLEN   1024
#define PMIX_MAX_KEYLEN    512

/* define a *wildcard* value for requests involving rank */
#define PMIX_RANK_WILDCARD -1

/* define a set of "standard" PMIx attributes that can
 * be queried. Implementations (and users) are free to extend as
 * desired, so the get functions need to be capable
 * of handling the "not found" condition. Note that these
 * are attributes of the system and the job as opposed to
 * values the application (or underlying MPI library)
 * might choose to expose - i.e., they are values provided
 * by the resource manager as opposed to the application. Thus,
 * these keys are RESERVED */
#define PMIX_ATTR_UNDEF      NULL

#define PMIX_CPUSET          "pmix.cpuset"      // (char*) hwloc bitmap applied to proc upon launch
#define PMIX_CREDENTIAL      "pmix.cred"        // (opal_byte_object*) security credential assigned to proc
#define PMIX_HOSTNAME        "pmix.hname"       // (char*) name of the host this proc is on
#define PMIX_SPAWNED         "pmix.spawned"     // (bool) true if this proc resulted from a call to PMIx_Spawn
/* scratch directory locations for use by applications */
#define PMIX_TMPDIR          "pmix.tmpdir"      // (char*) top-level tmp dir assigned to session
/* information about relative ranks as assigned */
#define PMIX_JOBID           "pmix.jobid"       // (char*) jobid assigned by scheduler
#define PMIX_APPNUM          "pmix.appnum"      // (uint32_t) app number within the job
#define PMIX_RANK            "pmix.rank"        // (uint32_t) process rank within the job
#define PMIX_GLOBAL_RANK     "pmix.grank"       // (uint32_t) rank spanning across all jobs in this session
#define PMIX_APP_RANK        "pmix.apprank"     // (uint32_t) rank within this app
#define PMIX_NPROC_OFFSET    "pmix.offset"      // (uint32_t) starting global rank of this job
#define PMIX_LOCAL_RANK      "pmix.lrank"       // (uint16_t) rank on this node within this job
#define PMIX_NODE_RANK       "pmix.nrank"       // (uint16_t) rank on this node spanning all jobs
#define PMIX_LOCALLDR        "pmix.lldr"        // (uint64_t) opal_identifier of lowest rank on this node within this job
#define PMIX_APPLDR          "pmix.aldr"        // (uint32_t) lowest rank in this app within this job
/* proc location-related info */
#define PMIX_PROC_MAP        "pmix.map"         // (byte_object) packed map of proc locations within this job
#define PMIX_LOCAL_PEERS     "pmix.lpeers"      // (char*) comma-delimited string of ranks on this node within this job
#define PMIX_LOCAL_CPUSETS   "pmix.lcpus"       // (byte_object) packed names and cpusets of local peers
/* size info */
#define PMIX_UNIV_SIZE       "pmix.univ.size"   // (uint32_t) #procs in this nspace
#define PMIX_JOB_SIZE        "pmix.job.size"    // (uint32_t) #procs in this job
#define PMIX_LOCAL_SIZE      "pmix.local.size"  // (uint32_t) #procs in this job on this node
#define PMIX_NODE_SIZE       "pmix.node.size"   // (uint32_t) #procs across all jobs on this node
#define PMIX_MAX_PROCS       "pmix.max.size"    // (uint32_t) max #procs for this job
/* topology info */
#define PMIX_NET_TOPO        "pmix.ntopo"       // (byte_object) network topology
#define PMIX_LOCAL_TOPO      "pmix.ltopo"       // (hwloc topo) local node topology


/****    PMIX ERROR CONSTANTS    ****/
/* PMIx errors are always negative, with 0 reserved for success */
#define PMIX_ERROR_MIN  -41  // set equal to number of non-zero entries in enum

typedef enum {
    PMIX_ERR_UNPACK_READ_PAST_END_OF_BUFFER = PMIX_ERROR_MIN,
    PMIX_ERR_COMM_FAILURE,
    PMIX_ERR_NOT_IMPLEMENTED,
    PMIX_ERR_NOT_SUPPORTED,
    PMIX_ERR_NOT_FOUND,
    PMIX_ERR_SERVER_NOT_AVAIL,
    PMIX_ERR_INVALID_NAMESPACE,
    PMIX_ERR_INVALID_SIZE,
    PMIX_ERR_INVALID_KEYVALP,
    PMIX_ERR_INVALID_NUM_PARSED,

    PMIX_ERR_INVALID_ARGS,
    PMIX_ERR_INVALID_NUM_ARGS,
    PMIX_ERR_INVALID_LENGTH,
    PMIX_ERR_INVALID_VAL_LENGTH,
    PMIX_ERR_INVALID_VAL,
    PMIX_ERR_INVALID_KEY_LENGTH,
    PMIX_ERR_INVALID_KEY,
    PMIX_ERR_INVALID_ARG,
    PMIX_ERR_NOMEM,
    PMIX_ERR_INIT,

    PMIX_ERR_DATA_VALUE_NOT_FOUND,
    PMIX_ERR_OUT_OF_RESOURCE,
    PMIX_ERR_RESOURCE_BUSY,
    PMIX_ERR_BAD_PARAM,
    PMIX_ERR_IN_ERRNO,
    PMIX_ERR_UNREACH,
    PMIX_ERR_TIMEOUT,
    PMIX_ERR_NO_PERMISSIONS,
    PMIX_ERR_PACK_MISMATCH,
    PMIX_ERR_PACK_FAILURE,
    
    PMIX_ERR_UNPACK_FAILURE,
    PMIX_ERR_UNPACK_INADEQUATE_SPACE,
    PMIX_ERR_TYPE_MISMATCH,
    PMIX_ERR_PROC_ENTRY_NOT_FOUND,
    PMIX_ERR_UNKNOWN_DATA_TYPE,
    PMIX_ERR_WOULD_BLOCK,
    PMIX_ERR_READY_FOR_HANDSHAKE,
    PMIX_ERR_HANDSHAKE_FAILED,
    PMIX_ERR_INVALID_CRED,
    PMIX_EXISTS,
    
    PMIX_ERROR,
    PMIX_SUCCESS
} pmix_status_t;


/****    PMIX DATA TYPES    ****/
typedef enum {
    PMIX_UNDEF = 0,
    PMIX_BYTE,           // a byte of data
    PMIX_STRING,         // NULL-terminated string
    PMIX_SIZE,           // size_t
    PMIX_PID,            // OS-pid

    PMIX_INT,
    PMIX_INT8,
    PMIX_INT16,
    PMIX_INT32,
    PMIX_INT64,

    PMIX_UINT,
    PMIX_UINT8,
    PMIX_UINT16,
    PMIX_UINT32,
    PMIX_UINT64,

    PMIX_FLOAT,
    PMIX_DOUBLE,

    PMIX_TIMEVAL,
    PMIX_TIME,

    PMIX_HWLOC_TOPO,
    PMIX_VALUE,
    PMIX_ARRAY,
    PMIX_RANGE,
    PMIX_APP,
    PMIX_INFO,
    PMIX_BUFFER,
    PMIX_BYTE_OBJECT,
    PMIX_KVAL,
    PMIX_MODEX,
    PMIX_PERSIST
} pmix_data_type_t;

/* define a scope for data "put" by PMI per the following:
 *
 * PMI_LOCAL - the data is intended only for other application
 *             processes on the same node. Data marked in this way
 *             will not be included in data packages sent to remote requestors
 * PMI_REMOTE - the data is intended solely for applications processes on
 *              remote nodes. Data marked in this way will not be shared with
 *              other processes on the same node
 * PMI_GLOBAL - the data is to be shared with all other requesting processes,
 *              regardless of location
 */
#define PMIX_SCOPE PMIX_UINT32
typedef enum {
    PMIX_SCOPE_UNDEF = 0,
    PMIX_INTERNAL,        // data used internally only
    PMIX_LOCAL,           // share to procs also on this node
    PMIX_REMOTE,          // share with procs not on this node
    PMIX_GLOBAL,          // share with all procs (local + remote)
    PMIX_NAMESPACE,       // used by Publish to indicate data is available to nspace only
    PMIX_UNIVERSAL,       // used by Publish to indicate data available to all
    PMIX_USER             // used by Publish to indicate data available to all user-owned nspaces
} pmix_scope_t; 

/* define a "persistence" policy for data published by
 * clients to the "global" nspace */
typedef enum {
    PMIX_PERSIST_INDEF = 0,   // retain until specifically deleted
    PMIX_PERSIST_PROC,        // retain until publishing process terminates
    PMIX_PERSIST_APP,         // retain until application terminates
    PMIX_PERSIST_SESSION      // retain until session/allocation terminates
} pmix_persistence_t;


/****    PMIX BYTE OBJECT    ****/
typedef struct {
    char *bytes;
    size_t size;
} pmix_byte_object_t;

/****    PMIX VALUE STRUCT    ****/
typedef struct {
    pmix_data_type_t type;
    size_t size;
    void *array;
} pmix_array_t;
/* NOTE: operations can supply a collection of values under
 * a single key by passing a pmix_value_t containing an
 * array of type PMIX_VALUE, with each array element
 * containing its own pmix_value_t object */

typedef struct {
    pmix_data_type_t type;
    union {
        uint8_t byte;
        char *string;
        size_t size;
        pid_t pid;
        int integer;
        int8_t int8;
        int16_t int16;
        int32_t int32;
        int64_t int64;
        unsigned int uint;
        uint8_t uint8;
        uint16_t uint16;
        uint32_t uint32;
        uint64_t uint64;
        float fval;
        double dval;
        struct timeval tv;
        pmix_array_t array;
        pmix_byte_object_t bo;
    } data;
} pmix_value_t;
/* allocate and initialize a specified number of value structs */
#define PMIX_VALUE_CREATE(m, n)                                         \
    do {                                                                \
        int _ii;                                                        \
        (m) = (pmix_value_t*)malloc((n) * sizeof(pmix_value_t));        \
        memset((m), 0, (n) * sizeof(pmix_value_t));                     \
        for (_ii=0; _ii < (int)(n); _ii++) {                            \
            (m)[_ii].type = PMIX_UNDEF;                                 \
        }                                                               \
    } while(0);

/* release a single pmix_value_t struct, including its data */
#define PMIX_VALUE_RELEASE(m)                                           \
    do {                                                                \
        PMIX_VALUE_DESTRUCT((m));                                       \
        free((m));                                                      \
    } while(0);

/* initialize a single value struct */
#define PMIX_VALUE_CONSTRUCT(m)                 \
    do {                                        \
        memset((m), 0, sizeof(pmix_value_t));   \
        (m)->type = PMIX_UNDEF;                 \
    } while(0);

/* release the memory in the value struct data field */
#define PMIX_VALUE_DESTRUCT(m)                                          \
    do {                                                                \
        if (PMIX_STRING == (m)->type && NULL != (m)->data.string) {     \
            free((m)->data.string);                                     \
        }                                                               \
    } while(0);

/* load a value */
#define PMIX_VALUE_LOAD(m, d, t)                                        \
    do {                                                                \
        (m)->type = (t);                                                \
        if (NULL == (d) && PMIX_STRING != (t) && PMIX_BYTE_OBJECT != (t)) { \
            /* just set the fields to zero */                           \
            memset(&(m)->data, 0, sizeof((m)->data));                   \
        } else {                                                        \
            switch((t)) {                                               \
            case PMIX_INDEF:                                            \
                break;                                                  \
            case PMIX_BYTE:                                             \
                memcpy(&((m)->data.byte), &(d), 1);                     \
                break;                                                  \
            case PMIX_STRING:                                           \
                (m)->data.string = strdup(&(d));                        \
                break;                                                  \
            case PMIX_SIZE:                                             \
                memcpy(&((m)->data.size), &(d), sizeof(size_t));        \
                break;                                                  \
            case PMIX_PID:                                              \
                memcpy(&((m)->data.pid), &(d), sizeof(pid_t));          \
                break;                                                  \
            case PMIX_INT:                                              \
                memcpy(&((m)->data.integer), &(d), sizeof(int));        \
                break;                                                  \
            case PMIX_INT8:                                             \
                memcpy(&((m)->data.int8), &(d), 1);                     \
                break;                                                  \
            case PMIX_INT16:                                            \
                memcpy(&((m)->data.int16), &(d), 2);                    \
                break;                                                  \
            case PMIX_INT32:                                            \
                memcpy(&((m)->data.int32), &(d), 4);                    \
                break;                                                  \
            case PMIX_INT64:                                            \
                memcpy(&((m)->data.int64), &(d), 8);                    \
                break;                                                  \
            case PMIX_UINT:                                             \
                memcpy(&((m)->data.uint), &(d), sizeof(int));           \
                break;                                                  \
            case PMIX_UINT8:                                            \
                memcpy(&((m)->data.uint8), &(d), 1);                    \
                break;                                                  \
            case PMIX_UINT16:                                           \
                memcpy(&((m)->data.uint16), &(d), 2);                   \
                break;                                                  \
            case PMIX_UINT32:                                           \
                memcpy(&((m)->data.uint32), &(d), 4);                   \
                break;                                                  \
            case PMIX_UINT64:                                           \
                memcpy(&((m)->data.uint64), &(d), 8);                   \
                break;                                                  \
            case PMIX_FLOAT:                                            \
                memcpy(&((m)->data.fval), &(d), sizeof(float));         \
                break;                                                  \
            case PMIX_DOUBLE:                                           \
                memcpy(&((m)->data.dval), &(d), sizeof(double));        \
                break;                                                  \
            case PMIX_TIMEVAL:                                          \
                memcpy(&((m)->data.tv), &(d), sizeof(struct timeval));  \
                break;                                                  \
            case PMIX_BYTE_OBJECT:                                      \
                (m)->data.bo.bytes = (d);                               \
                memcpy(&((m)->data.bo.size), &(d), sizeof(size_t));     \
                break;                                                  \
            }                                                           \
        }                                                               \
    } while(0);

/* unload a value */
#define PMIX_VALUE_UNLOAD(r, m, d, sz, t)                               \
    do {                                                                \
        *(d) = NULL;                                                    \
        *(sz) = 0;                                                      \
        (r) = PMIX_SUCCESS;                                             \
        if ((t) != (m)->type) {                                         \
            (r) = PMIX_ERR_TYPE_MISMATCH;                               \
        } else if (NULL == (d) ||                                       \
                   (NULL == *(d) && PMIX_STRING != type && PMIX_BYTE_OBJECT != type)) { \
            (r) = PMIX_ERR_BAD_PARAM;                                   \
        } else {                                                        \
            switch((t)) {                                               \
            case PMIX_UNDEF:                                            \
                (r) = PMIX_ERR_UNKNOWN_DATA_TYPE;                       \
                break;                                                  \
            case PMIX_BYTE:                                             \
                memcpy(*(d), &((m)->data.byte), 1);                     \
                *(sz) = 1;                                              \
                break;                                                  \
            case PMIX_STRING:                                           \
                if (NULL != (m)->data.string) {                         \
                    *(d) = strdup((m)->data.string);                    \
                    *(sz) = strlen(*(d));                               \
                }                                                       \
                break;                                                  \
            case PMIX_SIZE:                                             \
                memcpy(*(d), &((m)->data.size), sizeof(size_t));        \
                *(sz) = sizeof(size_t);                                 \
                break;                                                  \
            case PMIX_PID:                                              \
                memcpy(*(d), &((m)->data.pid), sizeof(pid_t));          \
                break;                                                  \
            case PMIX_INT:                                              \
                memcpy(*(d), &((m)->data.integer), sizeof(int));        \
                *(sz) = sizeof(int);                                    \
                break;                                                  \
            case PMIX_INT8:                                             \
                memcpy(*(d), &((m)->data.int8), 1);                     \
                *(sz) = 1;                                              \
                break;                                                  \
            case PMIX_INT16:                                            \
                memcpy(*(d), &((m)->data.int16), 2);                    \
                *(sz) = 2;                                              \
                break;                                                  \
            case PMIX_INT32:                                            \
                memcpy(*(d), &((m)->data.int32), 4);                    \
                *(sz) = 4;                                              \
                break;                                                  \
            case PMIX_INT64:                                            \
                memcpy(*(d), &((m)->data.int64), 8);                    \
                *(sz) = 8;                                              \
                break;                                                  \
            case PMIX_UINT:                                             \
                memcpy(*(d), &((m)->data.uint), sizeof(int));           \
                *(sz) = sizeof(int);                                    \
                break;                                                  \
            case PMIX_UINT8:                                            \
                memcpy(*(d), &((m)->data.uint8), 1);                    \
                *(sz) = 1;                                              \
                break;                                                  \
            case PMIX_UINT16:                                           \
                memcpy(*(d), &((m)->data.uint16), 2);                   \
                *(sz) = 2;                                              \
                break;                                                  \
            case PMIX_UINT32:                                           \
                memcpy(*(d), &((m)->data.uint32), 4);                   \
                *(sz) = 4;                                              \
                break;                                                  \
            case PMIX_UINT64:                                           \
                memcpy(*(d), &((m)->data.uint64), 8);                   \
                *(sz) = 8;                                              \
                break;                                                  \
            case PMIX_FLOAT:                                            \
                memcpy(*(d), &((m)->data.fval), sizeof(float));         \
                *(sz) = sizeof(float);                                  \
                break;                                                  \
            case PMIX_DOUBLE:                                           \
                memcpy(*(d), &((m)->data.dval), sizeof(double));        \
                *(sz) = sizeof(double);                                 \
                break;                                                  \
            case PMIX_TIMEVAL:                                          \
                memcpy(*(d), &((m)->data.tv), sizeof(struct timeval));  \
                *(sz) = sizeof(struct timeval);                         \
                break;                                                  \
            case PMIX_BYTE_OBJECT:                                      \
                if (NULL != (m)->data.bo.bytes && 0 < (m)->data.bo.size) { \
                    *(d) = (m)->data.bo.bytes;                          \
                    *(sz) = (m)->data.bo.size;                          \
                    (m)->data.bo.bytes = NULL;                          \
                    (m)->data.bo.size = 0;                              \
                } else {                                                \
                    *(d) = NULL;                                        \
                    *(sz) = 0;                                          \
                }                                                       \
                break;                                                  \
            }                                                           \
        }                                                               \
    }while(0);


/****    PMIX RANGE STRUCT    ****/
typedef struct {
    char nspace[PMIX_MAX_NSLEN];
    int *ranks;
    size_t nranks;
} pmix_range_t;
/* utility macros for working with pmix_range_t structs */
#define PMIX_RANGE_CREATE(m, n) \
    do {                                                                \
        (m) = (pmix_range_t*)malloc((n) * sizeof(pmix_range_t));        \
        memset((m), 0, (n) * sizeof(pmix_range_t));                     \
    } while(0);

#define PMIX_RANGE_RELEASE(m)                   \
    do {                                        \
        PMIX_RANGE_DESTRUCT((m));               \
        free((m));                              \
    } while(0);

#define PMIX_RANGE_CONSTRUCT(m)                 \
    do {                                        \
        memset((m), 0, sizeof(pmix_range_t));   \
    } while(0);

#define PMIX_RANGE_DESTRUCT(m) \
    do { \
        if (NULL != (m)->ranks) {               \
            free((m)->ranks);                   \
        }                                       \
    } while(0);


/****    PMIX INFO STRUCT    ****/
typedef struct {
    char key[PMIX_MAX_KEYLEN];
    pmix_value_t value;
} pmix_info_t;

/* utility macros for working with pmix_info_t structs */
#define PMIX_INFO_CREATE(m, n)                                  \
    do {                                                        \
        (m) = (pmix_info_t*)malloc((n) * sizeof(pmix_info_t));  \
        memset((m), 0, (n) * sizeof(pmix_info_t));              \
    } while(0);

#define PMIX_INFO_RELEASE(m)                    \
    do {                                        \
        PMIX_VALUE_DESTRUCT(&(m)->value);       \
        free((m));                              \
    } while(0);

#define PMIX_INFO_CONSTRUCT(m)                  \
    do {                                        \
        memset((m), 0, sizeof(pmix_value_t));   \
        (m)->type = PMIX_UNDEF;                 \
    } while(0);

#define PMIX_INFO_DESTRUCT(m) \
    do {                                        \
        PMIX_VALUE_DESTRUCT(&(m)->value);       \
    } while(0);




/****    PMIX APP STRUCT    ****/
typedef struct {
    char *cmd;
    int argc;
    char **argv;
    char **env;
    int maxprocs;
    pmix_info_t *info;
    size_t ninfo;
} pmix_app_t;
/* utility macros for working with pmix_app_t structs */
#define PMIX_APP_CREATE(m, n)                                   \
    do {                                                        \
        (m) = (pmix_app_t*)malloc((n) * sizeof(pmix_app_t));    \
        memset((m), 0, (n) * sizeof(pmix_app_t));               \
    } while(0);

#define PMIX_APP_RELEASE(m)                     \
    do {                                        \
        PMIX_APP_DESTRUCT((m));                 \
        free((m));                              \
    } while(0);

#define PMIX_APP_CONSTRUCT(m)                   \
    do {                                        \
        memset((m), 0, sizeof(pmix_app_t));     \
    } while(0);

#define PMIX_APP_DESTRUCT(m)                                    \
    do {                                                        \
        size_t _ii;                                             \
        if (NULL != (m)->cmd) {                                 \
            free((m)->cmd);                                     \
        }                                                       \
        if (NULL != (m)->argv) {                                \
            for (_ii=0; NULL != (m)->argv[_ii]; _ii++) {        \
                free((m)->argv[_ii]);                           \
            }                                                   \
            free((m)->argv);                                    \
        }                                                       \
        if (NULL != (m)->env) {                                 \
            for (_ii=0; NULL != (m)->env[_ii]; _ii++) {         \
                free((m)->env[_ii]);                            \
            }                                                   \
            free((m)->env);                                     \
        }                                                       \
        if (NULL != (m)->info) {                                \
            for (_ii=0; _ii < (m)->ninfo; _ii++) {              \
                PMIX_INFO_DESTRUCT(&(m)->info[_ii]);            \
            }                                                   \
        }                                                       \
    } while(0);    


/****    PMIX MODEX STRUCT    ****/
typedef struct {
    char nspace[PMIX_MAX_NSLEN];
    int rank;
    uint8_t *blob;
    size_t size;
} pmix_modex_data_t;
/* utility macros for working with pmix_modex_t structs */
#define PMIX_MODEX_CREATE(m, n)                                         \
    do {                                                                \
        (m) = (pmix_modex_data_t*)malloc((n) * sizeof(pmix_modex_data_t)); \
        memset((m), 0, (n) * sizeof(pmix_modex_data_t));                \
    } while(0);

#define PMIX_MODEX_RELEASE(m)                   \
    do {                                        \
        PMIX_MODEX_DESTRUCT((m));               \
        free((m));                              \
    } while(0);

#define PMIX_MODEX_CONSTRUCT(m)                         \
    do {                                                \
        memset((m), 0, sizeof(pmix_modex_data_t));      \
    } while(0);

#define PMIX_MODEX_DESTRUCT(m)                  \
    do {                                        \
        if (NULL != (m)->blob) {                \
            free((m)->blob);                    \
        }                                       \
    } while(0);


/****    CALLBACK FUNCTIONS FOR NON-BLOCKING OPERATIONS    ****/

/* define a callback function that is solely used by servers, and
 * not clients, to return modex data (i.e., data pushed to the
 * server by clients via the PMIx_Put function) in response
 * to "get" and "fence" operations. */
typedef void (*pmix_modex_cbfunc_t)(pmix_status_t status,
                                    pmix_modex_data_t data[],
                                    size_t ndata, void *cbdata);

/* define a callback function for calls to PMIx_Spawn_nb - the function
 * will be called upon completion of the spawn command. The status
 * will indicate whether or not the spawn succeeded. The nspace
 * of the spawned processes will be returned, along with any provided
 * callback data. Note that the returned nspace value will be
 * released by the library upon return from the callback function, so
 * the receiver must copy it if it needs to be retained */
typedef void (*pmix_spawn_cbfunc_t)(pmix_status_t status,
                                    char nspace[], void *cbdata);

/* define a callback for common operations that simply return
 * a status. Examples include the non-blocking versions of
 * Fence, Connect, and Disconnect */
typedef void (*pmix_op_cbfunc_t)(pmix_status_t status, void *cbdata);

/* define a callback function for calls to PMIx_Lookup_nb - the
 * function will be called upon completion of the command with the
 * status indicating the success of failure of the request. Any
 * retrieved data will be returned in an array of pmix_info_t structs.
 * The nspace of the process that provided the data is also returned.
 * Note that these structures will be released upon return from
 * the callback function, so the receiver must copy/protect the
 * data prior to returning if it needs to be retained */

typedef void (*pmix_lookup_cbfunc_t)(pmix_status_t status,
                                     pmix_info_t info[], size_t ninfo,
                                     char nspace[], void *cbdata);

/* define a callback function for the errhandler. Upon receipt of an
 * error notification, PMIx will execute the specified notification
 * callback function, providing:
 *
 * status - the error that occurred
 * ranges - the nspace and ranks of the affected processes. A NULL
 *          value indicates that the error occurred in the PMIx
 *          client library within this process itself
 * nranges - the number of ranges in the provided array
 * info - any additional info provided regarding the error.
 * ninfo - the number of info objects in the provided array
 *
 * Note that different resource managers will provide differing levels
 * of support for error notification to application processes. Thus, the
 * info array may be NULL or may contain detailed information of the error.
 * It is the responsibility of the application to parse any provided info array
 * for defined key-values if it so desires */
typedef void (*pmix_notification_fn_t)(pmix_status_t status,
                                       pmix_range_t ranges[], size_t nranges,
                                       pmix_info_t info[], size_t ninfo);

/* define a callback function for calls to PMIx_Get_nb. The status
 * indicates if the requested data was found or not - a pointer to the
 * pmix_value_t structure containing the found data is returned. The
 * pointer will be NULL if the requested data was not found. */ 
typedef void (*pmix_value_cbfunc_t)(pmix_status_t status,
                                    pmix_value_t *kv, void *cbdata);


/****    COMMON SUPPORT FUNCTIONS    ****/
/* Register an errhandler to report errors. Two types of errors
 * will be reported:
 *
 * (a) those that occur within the client library, but are not
 *     reportable via the API itself (e.g., loss of connection to
 *     the server). These errors typically occur during behind-the-scenes
 *     non-blocking operations.
 *
 * (b) job-related errors such as the failure of another process in
 *     the job, impending failure of hardware within the job's
 *     usage footprint, etc.
 *
 * See pmix_common.h for a description of the notification function */
void PMIx_Register_errhandler(pmix_notification_fn_t errhandler);

/* deregister the errhandler */
void PMIx_Deregister_errhandler(void);

/* Provide a string representation of a pmix_status_t value. Note
 * that the provided string is statically defined and must NOT be
 * free'd */
const char* PMIx_Error_string(pmix_status_t status);

/* Get the PMIx version string. Note that the provided string is
 * statically defined and must NOT be free'd  */
const char* PMIx_Get_version(void);


/* Key-Value pair management macros */
// TODO: add all possible types/fields here.

#define PMIX_VAL_FIELD_int(x) ((x)->data.integer)
#define PMIX_VAL_FIELD_uint32_t(x) ((x)->data.uint32)
#define PMIX_VAL_FIELD_uint16_t(x) ((x)->data.uint16)
#define PMIX_VAL_FIELD_string(x) ((x)->data.string)
#define PMIX_VAL_FIELD_float(x) ((x)->data.fval)

#define PMIX_VAL_TYPE_int    PMIX_INT
#define PMIX_VAL_TYPE_uint32_t PMIX_UINT32
#define PMIX_VAL_TYPE_uint16_t PMIX_UINT16
#define PMIX_VAL_TYPE_string PMIX_STRING
#define PMIX_VAL_TYPE_float  PMIX_FLOAT

#define PMIX_VAL_set_assign(_v, _field, _val )   \
    do {                                                            \
        (_v)->type = PMIX_VAL_TYPE_ ## _field;                      \
        PMIX_VAL_FIELD_ ## _field((_v)) = _val;                     \
    } while(0);

#define PMIX_VAL_set_strdup(_v, _field, _val )       \
    do {                                                                \
        (_v)->type = PMIX_VAL_TYPE_ ## _field;                          \
        PMIX_VAL_FIELD_ ## _field((_v)) = strdup(_val);                 \
    } while(0);

#define PMIX_VAL_SET_int     PMIX_VAL_set_assign
#define PMIX_VAL_SET_uint32_t  PMIX_VAL_set_assign
#define PMIX_VAL_SET_uint16_t  PMIX_VAL_set_assign
#define PMIX_VAL_SET_string  PMIX_VAL_set_strdup
#define PMIX_VAL_SET_float   PMIX_VAL_set_assign

#define PMIX_VAL_SET(_v, _field, _val )   \
    PMIX_VAL_SET_ ## _field(_v, _field, _val)

#define PMIX_VAL_FREE(_v) \
     PMIx_free_value_data(_v)

END_C_DECLS
#endif
